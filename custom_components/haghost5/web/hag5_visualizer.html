<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - GCode Visualizer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: Monospace;
            font-size: 13px;
            line-height: 24px;
            overscroll-behavior: none;
        }

        #status {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
            font-size: 16px;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>

<div id="status">Loading...</div>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.171.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.171.0/examples/jsm/"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// Codice del GCodeLoader direttamente incorporato
class GCodeLoader extends THREE.Loader {
    constructor(manager) {
        super(manager);
        this.splitLayer = false;
    }

    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new THREE.FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function (text) {
            try {
                onLoad(scope.parse(text));
            } catch (e) {
                if (onError) {
                    onError(e);
                } else {
                    console.error(e);
                }
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }

    parse(data, progressPercentage = 0) {
        let state = { x: 0, y: 0, z: 0, e: 0, f: 0, extruding: false, relative: false };
        const layers = [];
        let currentLayer = undefined;

        const completedMaterial = new THREE.LineBasicMaterial({ color: 0x00FF00 }); // Green
        const remainingMaterial = new THREE.LineBasicMaterial({ color: 0x0000FF }); // Blue

        function newLayer(line) {
            currentLayer = { vertex: [], pathVertex: [], z: line.z };
            layers.push(currentLayer);
        }

        function addSegment(p1, p2) {
            if (currentLayer === undefined) {
                newLayer(p1);
            }

            if (state.extruding) {
                currentLayer.vertex.push(p1.x, p1.y, p1.z);
                currentLayer.vertex.push(p2.x, p2.y, p2.z);
            } else {
                currentLayer.pathVertex.push(p1.x, p1.y, p1.z);
                currentLayer.pathVertex.push(p2.x, p2.y, p2.z);
            }
        }

        function delta(v1, v2) {
            return state.relative ? v2 : v2 - v1;
        }

        function absolute(v1, v2) {
            return state.relative ? v1 + v2 : v2;
        }

        const lines = data.replace(/;.+/g, '').split('\n');

        for (let i = 0; i < lines.length; i++) {
            const tokens = lines[i].split(' ');
            const cmd = tokens[0].toUpperCase();

            const args = {};
            tokens.splice(1).forEach(function (token) {
                if (token[0] !== undefined) {
                    const key = token[0].toLowerCase();
                    const value = parseFloat(token.substring(1));
                    args[key] = value;
                }
            });

            if (cmd === 'G0' || cmd === 'G1') {
                const line = {
                    x: args.x !== undefined ? absolute(state.x, args.x) : state.x,
                    y: args.y !== undefined ? absolute(state.y, args.y) : state.y,
                    z: args.z !== undefined ? absolute(state.z, args.z) : state.z,
                    e: args.e !== undefined ? absolute(state.e, args.e) : state.e,
                    f: args.f !== undefined ? absolute(state.f, args.f) : state.f,
                };

                if (delta(state.e, line.e) > 0) {
                    state.extruding = delta(state.e, line.e) > 0;

                    if (currentLayer == undefined || line.z != currentLayer.z) {
                        newLayer(line);
                    }
                }

                addSegment(state, line);
                state = line;

            } else if (cmd === 'G90') {
                state.relative = false;
            } else if (cmd === 'G91') {
                state.relative = true;
            } else if (cmd === 'G92') {
                const line = state;
                line.x = args.x !== undefined ? args.x : line.x;
                line.y = args.y !== undefined ? args.y : line.y;
                line.z = args.z !== undefined ? args.z : line.z;
                line.e = args.e !== undefined ? args.e : line.e;
            }
        }

        function addObject(vertex, extruding, progressPercentage) {
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertex, 3));

            const totalSegments = vertex.length / 3;
            const completedSegments = Math.floor(totalSegments * (progressPercentage / 100));
            const remainingSegments = totalSegments - completedSegments;

            // Completed segments
            const completedGeometry = new THREE.BufferGeometry();
            completedGeometry.setAttribute(
                'position',
                new THREE.Float32BufferAttribute(vertex.slice(0, completedSegments * 3), 3)
            );
            const completedSegmentsObject = new THREE.LineSegments(completedGeometry, completedMaterial);
            object.add(completedSegmentsObject);

            // Remaining segments
            const remainingGeometry = new THREE.BufferGeometry();
            remainingGeometry.setAttribute(
                'position',
                new THREE.Float32BufferAttribute(vertex.slice(completedSegments * 3), 3)
            );
            const remainingSegmentsObject = new THREE.LineSegments(remainingGeometry, remainingMaterial);
            object.add(remainingSegmentsObject);
        }

        const object = new THREE.Group();
        object.name = 'gcode';

        for (let i = 0; i < layers.length; i++) {
            const layer = layers[i];
            addObject(layer.vertex, true, progressPercentage);
        }

        object.rotation.set(-Math.PI / 2, 0, 0);
        return object;
    }
}

// Fine del codice del GCodeLoader

let camera, scene, renderer;
let currentFileName = null;
let progressPercentage = 0;
const statusDiv = document.getElementById('status');

init();
render();

function init() {
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.set(0, 0, 70);

    scene = new THREE.Scene();

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.addEventListener('change', render);

    window.addEventListener('resize', onWindowResize);

}

function loadGCode(fileName, progressPercentage = 0) {
    const loader = new GCodeLoader();
    loader.load(
        `gcodes/${fileName}`,
        (object) => {
            scene.clear();
            scene.add(object);
        },
        undefined,
        (error) => {
            console.error('Errore durante il caricamento:', error);
        }
    );
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    render();
}

function render() {
    renderer.render(scene, camera);
}

window.addEventListener('message', (event) => {
    const data = event.data;
    if (data.fileName) {
        loadGCode(data.fileName, data.progress || 0);
    }
    if (data.progress !== undefined) {
        progressPercentage = data.progress;
        statusDiv.textContent = `In stampa: ${data.fileName || 'N/A'} - Completato: ${progressPercentage}%`;
    }
});
    
</script>
</body>
</html>
